<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0"><meta property="og:title" content="Posts" />
<meta property="og:description" content="" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://waveszh.github.io/posts/" />

<meta property="og:updated_time" content="2020-03-15T18:20:31+08:00" />
<title>Posts | X-Y-Z</title>
<link rel="icon" href="/favicon.png" type="image/x-icon">


<link rel="stylesheet" href="/book.min.a5976c405dae433d8f29b44570050888016c89d73d4734909e982c645bbb4d05.css" integrity="sha256-pZdsQF2uQz2PKbRFcAUIiAFsidc9RzSQnpgsZFu7TQU=">


<script defer src="/search.min.4b5374ff6744223ff0adad18171a251385303ccb9ef225664aea3b0e539578fd.js" integrity="sha256-S1N0/2dEIj/wra0YFxolE4UwPMue8iVmSuo7DlOVeP0="></script>

<link rel="alternate" type="application/rss+xml" href="https://waveszh.github.io/posts/index.xml" title="X-Y-Z" />
<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->

  
</head>

<body>
  <input type="checkbox" class="hidden" id="menu-control" />
  <main class="flex container">

    <aside class="book-menu fixed">
      <nav>
<h2 class="book-brand">
  <a href="https://waveszh.github.io/"><span>X-Y-Z</span>
  </a>
</h2>


<div class="book-search">
  <input type="text" placeholder="Search" id="book-search-input" maxlength="64" />
  <div class="book-search-spinner spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>





    <ul>
<li><a href="/posts/"class=active><strong>Blog</strong></a></li>
</ul>





</nav>


<script>
(function() {
  var menu = document.querySelector("aside.book-menu nav");
  addEventListener("beforeunload", function(event) {
    localStorage.setItem("menu.scrollTop", menu.scrollTop);
  });
  menu.scrollTop = localStorage.getItem("menu.scrollTop");
})();
</script>

    </aside>

    <div class="book-posts">
      <header class="flex align-center justify-between book-header">
  <label for="menu-control">
    <img src="/svg/menu.svg" alt="Menu" />
  </label>
  <strong>Posts</strong>
</header>

      
  
  
  
  <article class="markdown">
    <h2>
      <a href="/posts/juc-synchronized/">深入理解JUC：synchronized</a>
    </h2>
    <h5>
      <strong>Mar 15, 2020</strong>
    </h5>
    <p><p>synchronized 关键字是 JAVA 中最基础的同步方式，以 JVM 底层的 monitor 监视器为基础实现的，但是由于使用 monitor 监视器会有上下文切换的损耗以及其他使用不便，JDK6 前推荐使用 LOCK 进行同步，随着 JVM 版本的升级，synchronized 得到了极大的优化：锁升级，锁粗化，锁消除等。</p>
        <a href="/posts/juc-synchronized/">...</a>
      
    </p>
  </article>
  
  <article class="markdown">
    <h2>
      <a href="/posts/juc-thread_pool_executor/">深入理解JUC：ThreadPoolExecutor</a>
    </h2>
    <h5>
      <strong>Jan 20, 2020</strong>
    </h5>
    <p><p>线程池是 JUC 的核心组件之一，简化了并发执行的实现，使得我们不需要关心线程的管理以及任务分配，只需要向池里丢任务就行了。<code>ThreadPoolExecutor</code> 是线程池的核心实现。</p>
        <a href="/posts/juc-thread_pool_executor/">...</a>
      
    </p>
  </article>
  
  <article class="markdown">
    <h2>
      <a href="/posts/kafka-consumer/">Kafka 源码解析：KafkaConsumer 实现机制</a>
    </h2>
    <h5>
      <strong>Jan 2, 2020</strong>
    </h5>
    <p><p>Kafka 消费者负责从 Kafka 集群拉取消息进行消费以及提交 offset 偏移量。Kafka 定义了消费组的概念，消费组包含若干个普通消费者和一个 leader 消费者，leader 消费者会将 Topic 下的分区分配给自己以及其他消费者，原则是<strong>同一个 Topic 的一个分区只能分配给一个消费者</strong>。多个消费者并行消费 Topic 中的数据，提高消费性能。由于消费者-Topic-分区数量均可变，需要进行 Rebalance 重新分配以保证消息消费的均衡性。</p>
        <a href="/posts/kafka-consumer/">...</a>
      
    </p>
  </article>
  
  <article class="markdown">
    <h2>
      <a href="/posts/netty-codec/">Netty Codec</a>
    </h2>
    <h5>
      <strong>Mar 31, 2019</strong>
    </h5>
    <p><p>Codec是编解码器，用于数据格式的转换。在网络通信中，底层都是通过字节流交互。故在Netty中需要实现应用程序的数据与字节流的转换：当进行远程
跨进程服务调用时，需要将被传输的Java对象编码成字节数组或者ByteBuffer对象；当远程服务读取字节数组或者ByteBuffer对象，需要将其还原成发送时的对象。
这听起来十分熟悉，就跟数据库存取数据一般，需要保证取的结果跟存时的一样。</p>
        <a href="/posts/netty-codec/">...</a>
      
    </p>
  </article>
  
  <article class="markdown">
    <h2>
      <a href="/posts/netty-handler/">Netty Handler</a>
    </h2>
    <h5>
      <strong>Mar 24, 2019</strong>
    </h5>
    <p><p>Web服务器通常都会使用filter来处理请求，这样就将处理流程分离和解耦。在Netty中也一样，其拥有<code>ChannelPipeline</code>作为过滤器通道，消息在里面流动和传递，由其中的
<code>Handler</code>拦截处理。<code>Handler</code>之间又由<code>Context（上下文）</code>作为纽扣连接起来。</p>
        <a href="/posts/netty-handler/">...</a>
      
    </p>
  </article>
  
  <article class="markdown">
    <h2>
      <a href="/posts/netty-channel/">Netty Channel</a>
    </h2>
    <h5>
      <strong>Mar 18, 2019</strong>
    </h5>
    <p><p>channel在编程中是一个很常见的东西，中文解释为：通道。其一般是数据传输的媒介，例如FileChannel，SocketChannel等，可以进行异步的I/O操作。
在Netty中也不例外，那么来看看其跟Java Nio Channel是如何配合的。</p>

<!--
带着问题找答案：

1. netty的channel与nio自带的channel有什么关系，是扩展还是组合，优势，不然为什么要重新实现？

2. channel扩展类的选择以及优化？
-->
        <a href="/posts/netty-channel/">...</a>
      
    </p>
  </article>
  
  <article class="markdown">
    <h2>
      <a href="/posts/netty-eventloop/">Netty EventLoop</a>
    </h2>
    <h5>
      <strong>Mar 5, 2019</strong>
    </h5>
    <p><p>Netty的NIO线程模型为Reactor，而EventLoop是Reactor的实现部分。</p>
        <a href="/posts/netty-eventloop/">...</a>
      
    </p>
  </article>
  
  <article class="markdown">
    <h2>
      <a href="/posts/juc-aqs_new/">深入理解JUC：AbstractQueuedSynchronizer</a>
    </h2>
    <h5>
      <strong>Mar 2, 2019</strong>
    </h5>
    <p><p><code>AbstractQueuedSynchronizer</code> 简称AQS, 是 JUC 并发框架的基石，支撑着 Lock 和 同步器的实现。其本质通过名称也能得知一二， <strong>Queued</strong>，通过队列实现同步，尝试获取资源的线程将封装成节点在队列中以自旋的方式获取资源，实现线程同步。</p>

<p>在 AQS 中存在两种队列，同步队列和条件(等待)队列。同步队列中的节点是尝试获取资源失败的线程构成的，而条件队列中的节点是由于某些条件而挂起的线程构成的，类似 Object.wait/notify，当条件激活时，条件队列中的节点转移到同步队列并唤醒。</p>
        <a href="/posts/juc-aqs_new/">...</a>
      
    </p>
  </article>
  
  



      

      
    </div>

    


  </main>

  
</body>

</html>
