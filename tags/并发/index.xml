<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>并发 on X-Y-Z</title>
    <link>https://waveszh.github.io/tags/%E5%B9%B6%E5%8F%91/</link>
    <description>Recent content in 并发 on X-Y-Z</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Sun, 15 Mar 2020 18:20:31 +0800</lastBuildDate>
    
	<atom:link href="https://waveszh.github.io/tags/%E5%B9%B6%E5%8F%91/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>深入理解JUC：synchronized</title>
      <link>https://waveszh.github.io/posts/juc-synchronized/</link>
      <pubDate>Sun, 15 Mar 2020 18:20:31 +0800</pubDate>
      
      <guid>https://waveszh.github.io/posts/juc-synchronized/</guid>
      <description>&lt;p&gt;synchronized 关键字是 JAVA 中最基础的同步方式，以 JVM 底层的 monitor 监视器为基础实现的，但是由于使用 monitor 监视器会有上下文切换的损耗以及其他使用不便，JDK6 前推荐使用 LOCK 进行同步，随着 JVM 版本的升级，synchronized 得到了极大的优化：锁升级，锁粗化，锁消除等。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>深入理解JUC：AbstractQueuedSynchronizer</title>
      <link>https://waveszh.github.io/posts/juc-aqs_new/</link>
      <pubDate>Sat, 02 Mar 2019 14:50:36 +0800</pubDate>
      
      <guid>https://waveszh.github.io/posts/juc-aqs_new/</guid>
      <description>&lt;p&gt;&lt;code&gt;AbstractQueuedSynchronizer&lt;/code&gt; 简称AQS, 是 JUC 并发框架的基石，支撑着 Lock 和 同步器的实现。其本质通过名称也能得知一二， &lt;strong&gt;Queued&lt;/strong&gt;，通过队列实现同步，尝试获取资源的线程将封装成节点在队列中以自旋的方式获取资源，实现线程同步。&lt;/p&gt;

&lt;p&gt;在 AQS 中存在两种队列，同步队列和条件(等待)队列。同步队列中的节点是尝试获取资源失败的线程构成的，而条件队列中的节点是由于某些条件而挂起的线程构成的，类似 Object.wait/notify，当条件激活时，条件队列中的节点转移到同步队列并唤醒。&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>